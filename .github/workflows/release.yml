name: Release
# This workflow builds and releases Vesta Launcher
# - Fails fast: if any build fails, the entire release is cancelled
# - Concurrency: cancels in-progress runs when new ones start
concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: true
on:
  workflow_dispatch:
    inputs:
      bump:
        description: 'Version bump type'
        type: choice
        default: 'none'
        options:
          - none
          - patch
          - minor
          - major
          - alpha
          - beta
      build_windows:
        description: 'Windows (x64 & ARM64)'
        type: boolean
        default: true
      build_macos:
        description: 'macOS (x64 & ARM64)'
        type: boolean
        default: true
      build_linux:
        description: 'Linux (x64 & ARM64)'
        type: boolean
        default: true
  push:
    tags:
      - 'v*'

jobs:
  bump-version:
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.bump != 'none'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      new_version: ${{ steps.bump.outputs.version }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: oven-sh/setup-bun@v1
      - id: bump
        run: |
          bun run version:bump ${{ github.event.inputs.bump }}
          AFTER=$(node -e "console.log(require('./vesta-launcher/src-tauri/tauri.conf.json').version)")
          if [ "$AFTER" = "" ]; then
            echo "Error: Version bump failed - no version found after bump"
            exit 1
          fi
          echo "version=$AFTER" >> $GITHUB_OUTPUT
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .
          git commit -m "chore: bump version to $AFTER"
          git push
          git tag "v$AFTER"
          git push --tags

  build:
    needs: [bump-version]
    if: always() && (needs.bump-version.result == 'success' || needs.bump-version.result == 'skipped')
    permissions:
      contents: read
    strategy:
      fail-fast: true
      matrix:
        include:
          - platform: 'windows-latest'
            args: '--target x86_64-pc-windows-msvc'
            enabled: ${{ github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.build_windows == 'true') }}
            name: 'Windows x64'
            target: 'x86_64-pc-windows-msvc'
          - platform: 'windows-11-arm'
            args: '--target aarch64-pc-windows-msvc'
            enabled: ${{ github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.build_windows == 'true') }}
            name: 'Windows ARM64'
            target: 'aarch64-pc-windows-msvc'
          - platform: 'macos-latest'
            args: '--target x86_64-apple-darwin'
            enabled: ${{ github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.build_macos == 'true') }}
            name: 'macOS x64'
            target: 'x86_64-apple-darwin'
          - platform: 'macos-latest'
            args: '--target aarch64-apple-darwin'
            enabled: ${{ github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.build_macos == 'true') }}
            name: 'macOS ARM64'
            target: 'aarch64-apple-darwin'
          - platform: 'ubuntu-latest'
            args: '--target x86_64-unknown-linux-gnu'
            enabled: ${{ github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.build_linux == 'true') }}
            name: 'Linux x64'
            target: 'x86_64-unknown-linux-gnu'
          - platform: 'ubuntu-24.04-arm'
            args: '--target aarch64-unknown-linux-gnu'
            enabled: ${{ github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.build_linux == 'true') }}
            name: 'Linux ARM64'
            target: 'aarch64-unknown-linux-gnu'
    
    runs-on: ${{ matrix.platform }}
    steps:
      - name: Determine checkout ref
        id: ref
        shell: bash
        run: |
          if [ "${{ needs.bump-version.result }}" = "success" ]; then
            REF="refs/tags/v${{ needs.bump-version.outputs.new_version }}"
          else
            REF="${{ github.ref }}"
          fi
          echo "ref=$REF" >> $GITHUB_OUTPUT
      
      - uses: actions/checkout@v4
        if: matrix.enabled
        with:
          ref: ${{ steps.ref.outputs.ref }}
          fetch-depth: 0

      - name: Install dependencies (Linux only)
        if: matrix.enabled && startsWith(matrix.platform, 'ubuntu')
        shell: bash
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev build-essential curl wget file libxdo-dev libssl-dev libayatana-appindicator3-dev librsvg2-dev pkg-config xdg-utils

      - name: Setup Node.js
        if: matrix.enabled
        uses: actions/setup-node@v4
        with:
          node-version: lts/*

      - name: Setup Bun
        if: matrix.enabled && matrix.platform != 'windows-11-arm'
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Setup Bun (Windows ARM64 - Node.js fallback)
        if: matrix.enabled && matrix.platform == 'windows-11-arm'
        uses: actions/setup-node@v4
        with:
          node-version: lts/*

      - name: Setup Rust
        if: matrix.enabled
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Cache Rust dependencies
        if: matrix.enabled
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: |
            . -> target
            vesta-launcher/src-tauri -> target
            crates/piston-lib -> target
          cache-all-crates: true

      - name: Install frontend dependencies
        if: matrix.enabled
        shell: bash
        run: |
          cd vesta-launcher
          if [ "${{ matrix.platform }}" == "windows-11-arm" ]; then
            npm install --legacy-peer-deps
          else
            bun install
          fi

      - name: Build Tauri App
        if: matrix.enabled
        shell: bash
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          CURSEFORGE_API_KEY: ${{ secrets.CURSEFORGE_API_KEY }}
        run: |
          cd vesta-launcher
          if [ "${{ matrix.platform }}" == "macos-latest" ]; then
            bun run tauri build --target ${{ matrix.target }}
          elif [[ "${{ matrix.platform }}" == "ubuntu"* ]]; then
            if [ "${{ matrix.platform }}" == "ubuntu-24.04-arm" ]; then
              bun run tauri build --target ${{ matrix.target }}
            else
              bun run tauri build --target ${{ matrix.target }}
            fi
          elif [ "${{ matrix.platform }}" == "windows-11-arm" ]; then
            npx tauri build --target ${{ matrix.target }}
          else
            bun run tauri build --target ${{ matrix.target }}
          fi

      - name: Upload to Cloudflare R2
        if: matrix.enabled
        shell: bash
        run: |
          # Configure AWS for R2
          aws configure set aws_access_key_id ${{ secrets.R2_ACCESS_KEY_ID }}
          aws configure set aws_secret_access_key ${{ secrets.R2_SECRET_ACCESS_KEY }}
          aws configure set region auto
          
          VERSION=$(node -e "console.log(require('./vesta-launcher/src-tauri/tauri.conf.json').version)")
          
          # Upload and rename to canonical format
          find target/${{ matrix.target }}/release/bundle/ -type f \( -name "*.msi*" -o -name "*.dmg*" -o -name "*.deb*" -o -name "*.AppImage*" -o -name "*.tar.gz*" \) -print0 | while IFS= read -r -d '' file; do
            filename=$(basename "$file")
            
            # Helper to check if it's a signature
            is_sig=false
            if [[ "$filename" == *.sig ]]; then
              is_sig=true
              base_file="${filename%.sig}"
            else
              base_file="$filename"
            fi
            
            ext="${base_file##*.}"
            
            target_name=""
            case "$ext" in
              msi)
                if [[ "${{ matrix.target }}" == *"aarch64"* ]]; then
                  target_name="Vesta_Launcher_${VERSION}_arm64.msi"
                else
                  target_name="Vesta_Launcher_${VERSION}_x64.msi"
                fi
                ;;
              dmg)
                if [[ "${{ matrix.target }}" == *"aarch64"* ]]; then
                  target_name="Vesta_Launcher_${VERSION}_aarch64.dmg"
                else
                  target_name="Vesta_Launcher_${VERSION}_x64.dmg"
                fi
                ;;
              deb)
                if [[ "${{ matrix.target }}" == *"aarch64"* ]]; then
                  target_name="vesta-launcher_${VERSION}_arm64.deb"
                else
                  target_name="vesta-launcher_${VERSION}_amd64.deb"
                fi
                ;;
              AppImage)
                target_name="Vesta_Launcher_${VERSION}_x86_64.AppImage"
                ;;
              gz)
                if [[ "$base_file" == *.tar.gz ]]; then
                  if [[ "${{ matrix.target }}" == *"aarch64"* ]]; then
                    target_name="Vesta_Launcher_${VERSION}_aarch64.app.tar.gz"
                  else
                    target_name="Vesta_Launcher_${VERSION}_x64.app.tar.gz"
                  fi
                fi
                ;;
            esac
            
            if [ -n "$target_name" ]; then
              if [ "$is_sig" = true ]; then
                target_name="$target_name.sig"
              fi
              echo "Uploading $filename as $target_name"
              aws s3 cp "$file" "s3://vesta-project/launcher/releases/$VERSION/$target_name" --endpoint-url https://b30108be91a7d16a9ae5d6c87838cec0.r2.cloudflarestorage.com
            else
              # Fallback for unrecognized files, but upload them anyway
              echo "Uploading $filename (unknown format)"
              aws s3 cp "$file" "s3://vesta-project/launcher/releases/$VERSION/$filename" --endpoint-url https://b30108be91a7d16a9ae5d6c87838cec0.r2.cloudflarestorage.com
            fi
          done

      - name: Upload build artifacts
        if: matrix.enabled
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts-${{ matrix.name }}
          path: target/${{ matrix.target }}/release/bundle/**/*
          if-no-files-found: error


  generate-manifest:
    needs: [build, bump-version]
    if: always() && (needs.build.result == 'success')
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4
      - name: Debug job execution
        shell: bash
        run: |
          echo "Generate-manifest job is running"
          echo "Build job result: ${{ needs.build.result }}"
      - name: Validate R2 secrets
        shell: bash
        run: |
          echo "Checking R2 secrets..."
          if [ -z "${{ secrets.R2_ACCESS_KEY_ID }}" ] || [ -z "${{ secrets.R2_SECRET_ACCESS_KEY }}" ]; then
            echo "R2 secrets not configured, skipping manifest generation"
            exit 0
          fi
          echo "R2 secrets are configured, proceeding with manifest generation"
      - name: Configure AWS for R2
        run: |
          aws configure set aws_access_key_id ${{ secrets.R2_ACCESS_KEY_ID }}
          aws configure set aws_secret_access_key ${{ secrets.R2_SECRET_ACCESS_KEY }}
          aws configure set region auto
      - name: Determine version
        id: version
        shell: bash
        run: |
          # Check if this is a tag push or workflow dispatch
          if [ "${{ github.event_name }}" = "push" ]; then
            # Tag push - extract version from tag
            VERSION="${{ github.ref_name }}"
            VERSION="${VERSION#v}"
          elif [ "${{ needs.bump-version.result }}" = "success" ]; then
            # Workflow dispatch with version bump
            VERSION="${{ needs.bump-version.outputs.new_version }}"
          else
            # Workflow dispatch without bump - read current version
            VERSION=$(node -e "console.log(require('./vesta-launcher/src-tauri/tauri.conf.json').version)")
          fi
          
          if [ -z "$VERSION" ]; then
            echo "Error: Version is empty. For tag pushes, ensure tag starts with 'v' followed by semver. For dispatch, check bump-version output."
            exit 1
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
      - name: Generate and upload latest.json
        run: |
          VERSION=${{ steps.version.outputs.version }}
          PUB_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          NOTES="Automatic release"
          
          # List files in the version folder
          FILES=$(aws s3 ls s3://vesta-project/launcher/releases/$VERSION/ --endpoint-url https://b30108be91a7d16a9ae5d6c87838cec0.r2.cloudflarestorage.com | awk '{print $4}')
          
          # Collect files per platform, preferring updater-compatible ones
          declare -A platform_files
          for file in $FILES; do
            # Skip signature files in this loop
            if [[ "$file" == *.sig ]]; then continue; fi

            PLATFORM=""
            case "$file" in
              Vesta_Launcher_${VERSION}_x64.msi)
                PLATFORM="windows-x86_64"
                ;;
              Vesta_Launcher_${VERSION}_arm64.msi)
                PLATFORM="windows-aarch64"
                ;;
              Vesta_Launcher_${VERSION}_x64.dmg)
                PLATFORM="darwin-x86_64"
                ;;
              Vesta_Launcher_${VERSION}_aarch64.dmg)
                PLATFORM="darwin-aarch64"
                ;;
              Vesta_Launcher_${VERSION}_x86_64.AppImage)
                PLATFORM="linux-x86_64"
                ;;
              vesta-launcher_${VERSION}_arm64.deb)
                if [ -z "${platform_files["linux-aarch64"]}" ]; then
                    PLATFORM="linux-aarch64"
                fi
                ;;
              vesta-launcher_${VERSION}_amd64.deb)
                if [ -z "${platform_files["linux-x86_64"]}" ]; then
                    PLATFORM="linux-x86_64"
                fi
                ;;
            esac

            if [ -n "$PLATFORM" ]; then
                # For macOS, always prefer .dmg over .tar.gz
                if [[ "$PLATFORM" == darwin-* ]]; then
                  if [[ "$file" == *.dmg ]]; then
                    platform_files[$PLATFORM]=$file
                  fi
                else
                  # Prefer updater artifacts (tar.gz, AppImage, msi) over others if they exist
                  if [ -z "${platform_files[$PLATFORM]}" ] || [[ "$file" == *.tar.gz ]] || [[ "$file" == *.AppImage ]] || [[ "$file" == *.msi ]]; then
                      platform_files[$PLATFORM]=$file
                  fi
                fi
            fi
          done
          
          # Build platforms JSON
          PLATFORMS="{"
          FIRST=true
          for PLATFORM in "${!platform_files[@]}"; do
            if [ "$FIRST" = true ]; then
              FIRST=false
            else
              PLATFORMS="$PLATFORMS,"
            fi
            FILE="${platform_files[$PLATFORM]}"
            
            # Fetch signature content from R2 and clean up "untrusted comment" if present
            SIG_FILE="$FILE.sig"
            echo "Fetching signature for $FILE from $SIG_FILE"
            SIGNATURE_RAW=$(aws s3 cp "s3://vesta-project/launcher/releases/$VERSION/$SIG_FILE" - --endpoint-url https://b30108be91a7d16a9ae5d6c87838cec0.r2.cloudflarestorage.com 2>/dev/null || echo "")
            # Only take the second line (the actual signature) if it's a multisign/tauri-style signature file
            if echo "$SIGNATURE_RAW" | grep -q "untrusted comment"; then
              SIGNATURE=$(echo "$SIGNATURE_RAW" | sed -n '2p')
            else
              SIGNATURE="$SIGNATURE_RAW"
            fi
            
            PLATFORMS="$PLATFORMS
            \"$PLATFORM\": {
              \"url\": \"https://pub-f5abfd388a694b88b657a52e2e95b451.r2.dev/launcher/releases/$VERSION/$FILE\",
              \"signature\": \"$SIGNATURE\"
            }"
          done
          PLATFORMS="$PLATFORMS
          }"
          
          cat > latest.json << EOF
          {
            "version": "$VERSION",
            "notes": "$NOTES",
            "pub_date": "$PUB_DATE",
            "platforms": $PLATFORMS
          }
          EOF
          
          aws s3 cp latest.json s3://vesta-project/launcher/releases/ --endpoint-url https://b30108be91a7d16a9ae5d6c87838cec0.r2.cloudflarestorage.com

  create-github-release:
    needs: [build, generate-manifest, bump-version]
    if: always() && needs.build.result == 'success' && needs.generate-manifest.result == 'success' && (github.event_name == 'workflow_dispatch' || github.event_name == 'push')
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Determine version
        id: version
        shell: bash
        run: |
          # Check if this is a tag push or workflow dispatch
          if [ "${{ github.event_name }}" = "push" ]; then
            # Tag push - extract version from tag
            VERSION="${{ github.ref_name }}"
            VERSION="${VERSION#v}"
          elif [ "${{ needs.bump-version.result }}" = "success" ]; then
            # Workflow dispatch with version bump
            VERSION="${{ needs.bump-version.outputs.new_version }}"
          else
            # Workflow dispatch without bump - read current version
            VERSION=$(node -e "console.log(require('./vesta-launcher/src-tauri/tauri.conf.json').version)")
          fi
          
          if [ -z "$VERSION" ]; then
            echo "Error: Version is empty. For tag pushes, ensure tag starts with 'v' followed by semver. For dispatch, check bump-version output."
            exit 1
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
      
      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/
      
      - name: List downloaded artifacts
        shell: bash
        run: |
          # Only list artifacts matching the canonical product filenames
          find artifacts/ -type f \( -iname "*Vesta_Launcher*.*msi" -o -iname "*Vesta_Launcher*.*dmg" -o -iname "*Vesta_Launcher*.*AppImage" -o -iname "*vesta-launcher*.*deb" \) | sort
      
      - name: Validate artifacts
        shell: bash
        run: |
          ARTIFACT_COUNT=$(find artifacts/ -type f \( -iname "*Vesta_Launcher*.*msi" -o -iname "*Vesta_Launcher*.*dmg" -o -iname "*Vesta_Launcher*.*AppImage" -o -iname "*vesta-launcher*.*deb" \) | wc -l)
          if [ "$ARTIFACT_COUNT" -lt 3 ]; then
            echo "Error: Expected at least 3 build artifacts, found $ARTIFACT_COUNT"
            echo "This likely means some builds failed. Check the build job logs."
            exit 1
          fi
          echo "Found $ARTIFACT_COUNT build artifacts - proceeding with release"
      
      - name: Generate changelog
        id: changelog
        shell: bash
        run: |
          echo "::group::Changelog Generation Debug Logs"
          
          # Get the current tag
          CURRENT_TAG="v${{ steps.version.outputs.version }}"
          echo "Current tag: $CURRENT_TAG"
          
          # Get the previous tag (second most recent by version)
          PREVIOUS_TAG=$(git tag --sort=-version:refname | head -2 | tail -1 || echo "")
          echo "Previous tag: $PREVIOUS_TAG"
          
          # Show all available tags for debugging
          echo "All tags (sorted by version):"
          git tag --sort=-version:refname | head -5 || echo "No tags found"
          
          echo "## Changelog" > changelog.md
          echo "" >> changelog.md
          
          if [ -n "$PREVIOUS_TAG" ] && git rev-parse "$CURRENT_TAG" >/dev/null 2>&1; then
            echo "Tag validation passed - both tags exist"
            # Check if there are commits between previous and current tag
            COMMIT_COUNT=$(git rev-list --count ${PREVIOUS_TAG}..${CURRENT_TAG} 2>/dev/null || echo "0")
            echo "Commit count between $PREVIOUS_TAG..$CURRENT_TAG: $COMMIT_COUNT"
            if [ "$COMMIT_COUNT" -gt 0 ]; then
              echo "Generating changelog from git log..."
              git log --pretty=format:"- %s (%h)" --no-merges --grep="chore: bump version" --invert-grep ${PREVIOUS_TAG}..${CURRENT_TAG} >> changelog.md 2>/dev/null || echo "- Release notes" >> changelog.md
            else
              echo "No commits found, adding fallback message"
              echo "- No changes since last release" >> changelog.md
            fi
          else
            echo "Tag validation failed - using initial release message"
            echo "- Initial release" >> changelog.md
          fi
          
          echo "Changelog content after generation:"
          cat changelog.md
          
          # Safety check: ensure changelog.md exists and has content
          if [ ! -s changelog.md ]; then
            echo "Safety check: changelog.md is empty, adding fallback content"
            echo "- No changes or initial release" > changelog.md
          else
            echo "Safety check: changelog.md has content"
          fi
          
          # Use a highly unique delimiter for multiline output (random base64 to avoid conflicts)
          DELIMITER=$(dd if=/dev/urandom bs=15 count=1 status=none | base64 | tr -d '\n')
          echo "Using delimiter: $DELIMITER"
          
          echo "Writing to GITHUB_OUTPUT..."
          echo "changelog<<$DELIMITER" >> $GITHUB_OUTPUT
          cat changelog.md >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "$DELIMITER" >> $GITHUB_OUTPUT
          
          echo "GITHUB_OUTPUT content preview:"
          tail -10 $GITHUB_OUTPUT || echo "Could not read GITHUB_OUTPUT"
          
          echo "::endgroup::"
      
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.version.outputs.version }}
          name: Vesta Launcher v${{ steps.version.outputs.version }}
          body: |
            ## Vesta Launcher v${{ steps.version.outputs.version }}
            
            Automatic release build for Vesta Launcher.
            
            ${{ steps.changelog.outputs.changelog }}
          files: |
            artifacts/**/*Vesta_Launcher*.msi
            artifacts/**/*Vesta_Launcher*.dmg
            artifacts/**/*vesta-launcher*.deb
            artifacts/**/*Vesta_Launcher*.AppImage
            artifacts/**/*Vesta_Launcher*.tar.gz
          draft: false
          prerelease: ${{ contains(steps.version.outputs.version, 'alpha') || contains(steps.version.outputs.version, 'beta') }}